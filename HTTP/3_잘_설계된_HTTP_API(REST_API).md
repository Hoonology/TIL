# REST API

# INDEX
- [좋은 REST API를 디자인 하는 방법](#좋은-rest-api를-디자인-하는-방법)
- [REST 성숙도 모델 - 0단계](#rest-성숙도-모델---0단계)
- [REST 성숙도 모델 - 1단계](#rest-성숙도-모델---1단계)
- [REST 성숙도 모델 - 2단계](#rest-성숙도-모델---2단계)
- [REST 성숙도 모델 - 3단계](#rest-성숙도-모델---3단계)
- [miniQuiz](#miniquiz)
---

# References
- [5가지의 기본적인 REST API 디자인 가이드](https://blog.restcase.com/5-basic-rest-api-design-guidelines/)
- [호주 정부 API 작성 가이드](https://api.gov.au/)
- [구글 API 작성 가이드](https://cloud.google.com/apis/design?hl=ko)
- [MS의 REST API 가이드라인](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md)

---

잘 설계된 HTTP API가 무엇이길래 그렇게 레스트풀 API를 사람들이 찾는가에 대해 의문을 가져 공부를 시작했다.
우선, 내 친구 ChatGPT에게 먼저 물어본 결과,

> REST API(Representational State Transfer Application Programming Interface)는 ****서로 다른 시스템이 인터넷을 통해 서로 통신할 수 있도록 하는 웹 서비스를 만드는 데 사용되는 소프트웨어 아키텍처 스타일****입니다.  
간단히 말해서 HTTP 프로토콜을 사용하여 인터넷을 통해 서로 다른 소프트웨어 응용 프로그램이 데이터를 교환하고 상호 작용할 수 있는 방법을 정의하는 일련의 규칙 및 프로토콜입니다.

>REST API는 고유한 URL로 식별되는 리소스 개념을 기반으로 합니다. 리소스에서 수행할 수 있는 다양한 작업에 해당하는 ***GET, POST, PUT*** 및 ***DELETE***와 같은 다양한 HTTP 메서드를 사용하여 각 리소스에 액세스할 수 있습니다.
예를 들어 전자 상거래 웹사이트용 REST API를 사용하면 URL /products에 대한 GET 요청을 사용하여 제품 목록을 검색하고, 동일한 URL에 대한 POST 요청을 사용하여 새 제품을 만들고, /products/{product_id}에 요청을 PUT하고 동일한 URL에 대한 DELETE 요청을 사용하여 제품을 삭제합니다.

>REST API는 개발자가 인터넷을 통해 다양한 서비스 및 시스템과 상호 작용할 수 있는 웹 및 모바일 애플리케이션을 생성하는 데 널리 사용되므로 광범위한 서비스 및 플랫폼과 통합할 수 있는 복잡한 애플리케이션을 보다 쉽게 ​​구축할 수 있습니다.

</br>

#### *'제대로 보내고 받을 수 있는' 일종의 규약*

</br>

클라이언트 - 서버  
( 데이터와 리소스 요청 - 요청에 따른 응답 전달 - 메뉴판 )   

HTTP 프로토콜 기반으로 요청과 응답에 따라 리소스를 주고받기 위해서 알아보기 쉽고 잘 작성된 메뉴판이 필요하다. = API의 필요성

</br>

# 좋은 REST API를 디자인 하는 방법
![Img](https://images.velog.io/images/estell/post/f1eb64d7-f7d9-4379-a030-509f68748fb1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-12%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.51.17.png)

2단계 까지 적용해도 좋은 API 디자인이라고 한다. ( **HTTP API** 라고 한다. )

## REST 성숙도 모델 - 0단계
0단계는 좋은 REST API를 작성하기 위한 기본 단계, API를 REST API라고 할 수는 없다.  
나머지 성숙도 모델의 초기 레벨은 클라이언트와 서버 간의 원격 프로시저 호출(RPC)을 위한 전송 프로토콜로 HTTP를 사용하는 것이 특징입니다. 이 수준은 RESTful 원칙을 사용하지 않으며 일반적으로 원격 프로시저 호출(RPI)이라고 합니다.
단순히 HTTP 프로토콜을 사용하기만 해도 된다.

허준이라는 이름의 주치의의 예약 가능한 시간을 확인하고, 어떤 특정 시간에 예약하는 상황을 예로 들어 보겠습니다.
![0](/HTTP/assets/3_잘_설계된_HTTP_API/0.png)

## REST 성숙도 모델 - 1단계
1단계에서는 개별 리소스와의 통신을 준수
앞서 0단계에서는 모든 요청에서 엔드포인트로 ```/appointment```를 사용하였습니다. 하지만 1단계에서는 요청하는 리소스가 무엇인지에 따라 각기 다른 엔드포인트로 구분하여 사용해야 합니다. 
이 수준에서는 클라이언트가 GET, POST, PUT 및 DELETE와 같은 HTTP 메서드를 사용하여 리소스 표현을 검색하거나 조작할 수 있도록 하는 URI에 의해 리소스가 도입되고 식별됩니다. 그러나 HTTP 동사의 사용은 아직 완전히 최적화되지 않았으며 API에는 여전히 RPI 요소가 포함될 수 있습니다.
![0](/HTTP/assets/3_잘_설계된_HTTP_API/1.png)
위의 예시에서 예약 가능한 시간 확인이라는 요청의 응답으로 받게 되는 자원(리소스)은 허준이라는 의사의 예약 가능한 시간대입니다. 그렇기 때문에 요청 시 /doctors/허준이라는 엔드포인트를 사용한 것을 볼 수 있습니다. 뿐만 아니라, 특정 시간에 예약하게 되면, 실제 slot이라는 리소스의 123이라는 id를 가진 리소스가 변경되기 때문에, 하단의 특정 시간에 예약이라는 요청에서는 /slots/123으로 실제 변경되는 리소스를 엔드포인트로 사용하였습니다.

예시와 같이, 어떤 리소스를 변화시키는지 혹은 어떤 응답이 제공되는지에 따라 각기 다른 엔드포인트를 사용하기 때문에, 적절한 엔드포인트를 작성하는 것이 중요합니다.
엔드포인트 작성 시에는 동사, HTTP 메소드, 혹은 어떤 행위에 대한 단어 사용은 지양하고, 리소스에 집중해 명사 형태의 단어로 작성하는 것이 바람직 방법입니다.

더불어 요청에 따른 응답으로 리소스를 전달할 때에도 사용한 리소스에 대한 정보와 함께 리소스 사용에 대한 성공/실패 여부를 반환해야 합니다. 예를 들어 만약 김코딩 환자가 허준 의사에게 9시에 예약을 진행하였으나, 해당 시간이 마감되어 예약이 불가능하다고 가정할 때, 아래와 같이 리소스 사용에 대한 실패 여부를 포함한 응답을 받아야 합니다.
![0](/HTTP/assets/3_잘_설계된_HTTP_API/2.png)


## REST 성숙도 모델 - 2단계
REST 성숙도 모델 2단계에서는 CRUD에 맞게 적절한 HTTP 메소드를 사용하는 것에 중점을 둡니다.  
이 수준의 초점은 HTTP 동사 및 상태 코드의 적절한 사용에 있습니다. API는 RESTful 원칙을 따르고 HTTP 메서드와 상태 코드를 원래 용도대로 사용합니다. API 디자인은 리소스 중심이며 하이퍼미디어 링크를 사용하여 리소스 간의 관계를 나타냅니다.


 0단계와 1단계 예시에서 보았듯, 모든 요청을 CRUD에 상관없이 POST로 하고 있습니다. 그러나 REST 성숙도 모델 2단계에 따르면 이는 CRUD에 따른 적합한 메소드를 사용한 것은 아닙니다.
![0](/HTTP/assets/3_잘_설계된_HTTP_API/3.png)


## REST 성숙도 모델 - 3단계

마지막 단계는 HATEOAS(Hypertext As The Engine Of Application State)라는 약어로 표현되는 하이퍼미디어 컨트롤을 적용합니다. 3단계의 요청은 2단계와 동일하지만, 응답에는 리소스의 URI를 포함한 링크 요소를 삽입하여 작성한다는 것이 다릅니다.

이때 응답에 들어가게 되는 링크 요소는 응답을 받은 다음에 할 수 있는 다양한 액션들을 위해 많은 하이퍼미디어 컨트롤을 포함하고 있습니다.
![0](/HTTP/assets/3_잘_설계된_HTTP_API/4.png)
이 수준에서 API는 HATEOAS(응용 프로그램 상태 엔진)로 하이퍼미디어를 완전히 수용하여 클라이언트가 API에서 제공하는 링크 및 메타데이터를 기반으로 리소스를 동적으로 탐색하고 검색할 수 있도록 합니다. API는 진정으로 자기 설명적이며 클라이언트는 API와 상호 작용하기 위해 대역 외 정보에 의존할 필요가 없습니다.


전반적으로 Rest Maturity Model은 RESTful API 구현의 성숙도를 평가하는 데 유용한 도구이며 API 디자인을 개선하고 RESTful 원칙을 채택하기 위한 가이드로 사용할 수 있습니다.

<br>

# miniQuiz

1. 여러분은 영화 예매 사이트의 백엔드 개발자이며, 잔여 좌석을 확인하는 엔드포인트를 작성해야 합니다.  
``GET /inquiry`` 라는 엔드포인트를 만들었는데, 시니어 개발자로부터 REST 원칙을 따르지 않았다는 지적을 받았습니다. 그 이유로 적절한 것을 고르시오. C


    A.
    HTTP 메서드인 GET 대신에 PUT을 사용하는 것이 적절했기 때문


    B.
    엔드포인트에 동사를 사용했기 때문


    C.
    엔드포인트에 좌석에 대한 리소스를 지칭하지 않았기 때문


    D.
    응답에 Location 헤더 정보를 전달하지 않았기 때문

    해설  
    A. 잔여좌석을 확인하기 위한 요청의 HTTP 메서드는 GET을 사용하는 것이 적절합니다.  
    B. 엔드포인트에는 리소스를 지칭하는 명사 사용이 권장되며, 해당 엔드포인트 inquiry는 행위에 대한 명사형으로 권장되지 않습니다.  
    D. 응답에 Location 헤더 정보를 전달했는지는 알 수 없습니다.

<br>


2. 요리 레시피를 제공하는 웹사이트를 만들기 위해, 냉장고에 있는 재료 목록을 조회해야 합니다. 엔드포인트로(endpoint)는 어떤 것이 적절할까요?


    A.
    ```GET /refrigerator```


    B.
    ```GET /recipe```


    C.
    ```POST /inquiry```

    정답

    D.
    ```GET /ingredient```

    해설  
    ```GET /refrigerator``` 도 얼핏 맞는 설명처럼 보이나, 결과적으로 응답에는 재료 목록이 전달됩니다. 엔드포인트는 어떻게 요청되는지, 혹은 어디로부터 나온 요청인지는 중요하지 않습니다. 어떤 응답이 제공되는가가 중요하므로, 가장 적절한 엔드포인트는 ```GET /ingredient``` 입니다.

<br>

3. 여러분은 트위틀러 웹사이트의 기획을 전달받은 백엔드 개발자입니다. 데이터베이스에는 트윗이 너무 많으므로, 트윗 목록을 보여주기 위해 무한 스크롤을 이용해 추가적으로 트윗을 불러오려고 합니다. 이때 추가적인 트윗을 불러오기 위해 백엔드 개발자로서 작성해야 할 엔드포인트(endpoint)로는 어떤 것이 적절할까요?


    A.
    ```GET /more-tweets```


    B.
    ```POST /infinite-scroll```


    C.
    ```PUT /tweets```


    **D.
    ```GET /tweets?offset=10&limit=10```**

    HTTP 메서드는 GET이 적합하며, 엔드포인트는 응답을 통해 받게 되는 리소스가 무엇인지를 알려주는 명확한 명사 형태로 작성되는 것이 적절합니다.
    
    해설

    무한 스크롤을 이용해 추가적으로 트윗을 불러온다는 조건이 있기 때문에, /more-tweets도 얼핏 맞는 것처럼 보입니다. 그러나 결과적으로 응답으로 제공되는 리소스가 트윗이므로, 이 경우에는 트윗 목록을 조회하기 위해 처음에 사용했던 엔드포인트 (GET /tweets) 를 재사용하는 편이 보다 적절합니다. 수십, 수백개의 트윗을 한꺼번에 응답으로 받기에는 상당한 양의 payload가 전달되므로, 이 때 백엔드에서는 페이지네이션(pagination)을 이용해 트윗 목록을 끊어주는 게 좋습니다.

    예를 들어, 총 120개의 트윗 중 인덱스가 20~30인 트윗, 즉 열 개의 트윗만 가져온다고 가정해 봅시다. 보통 이 때 관습적으로 사용되는 Query Parameter는 offset, limit으로 이 경우 offset=20&limit=10 으로 해당 트윗을 가져올 수 있습니다.

    <br>

4. 위치 기반 맛집 탐색 앱의 기획을 전달받은 백엔드 개발자입니다. 특정 위치 기반의 모든 식당 목록을 조회하고, 그중 한식만 필터링하는 기능이 추가됩니다. 해당 요청을 수행하기에 알맞은 엔드포인트(endpoint)로는 어떤 것이 적절할까요?

    A. ```GET /filter/korean```  
    **B. ```GET /restaurants?coordinate=126.9178889,37.5561619&type=korean```**  
    C. ```GET /filter?type=korean```  
    D. ```GET /get-restaurants?coordinate=126.9178889,37.5561619&type=korean```

    해설  
    리소스 요구사항은 식당 목록이므로, 엔드포인트만 보고도 식당 목록이 응답으로 전달될 것을 예상할 수 있도록 이름을 짓는 편이 좋습니다. 따라서, 엔드포인트에는 resturants 와 같이 리소스를 지칭하는 단어가 포함되어 있어야 하며, get 과 같은 동사는 사용하지 않습니다.

    추가적으로 필터링을 위해서 해당 리소스의 필터링 조건을 Query Parameter로 전달하는 것이 바람직하며, 여기에는 한식임을 나타낼 만한 type=korean 을 추가하였습니다.

    위치 기반의 식당이므로 특정 반경의 중심이 될 만한 좌표(coordinate)를 Query Parameter로 제공했으며, 이 역시도 필터링의 한 방법으로 볼 수 있습니다.



<br>

5. 파이널 프로젝트 때 만든 앱이 대박이 나서, 국제화에 대한 요구사항이 추가되었습니다. 따라서, 다음과 같이 요청에 따라 국제화가 적용된 응답이 API 서버로부터 제공되어야 합니다.

    예) 한국어 응답과 영어 응답의 예제
    ```json
        // 한국어
        { "category": ["한식", "이탈리안", "일식", "중식"] } 

        // 영어
        { "category": ["Korean", "Italian", "Japanese", "Chinese"] }
    ```

    어떤 방법으로 요청을 개선하는 것이 좋을까요?


    A.
    기존 엔드포인트 대신, 언어별로 별도의 엔드포인트를 작성한다.   
    ```GET /category/ko-KR, GET /category/en-US```


    **B.
    ```Accept-Language``` 헤더에 따라 다른 응답을 제공한다.**


    C.
    브라우저 언어 설정을 JavaScript를 이용해 가져온다.


    D.
    클라이언트 코드의 전역 상태에 언어 정보를 담는다.

    해설  
    언어별로 별도의 엔드포인트를 작성하는 예를 종종 발견할 수 있지만, 기존 엔드포인트를 대신하는 것은 하위 호환성을 고려하지 않은 방식입니다. 그보다 더 좋은 예는 Accept-Language 헤더를 요청에 함께 제공하는 것입니다. 이는 기존 엔드포인트를 그대로 활용할 수도 있다는 장점이 있습니다. 또한 Accept-Language 헤더의 목적이 애초에 클라이언트가 이해할 수 있는 언어 설정이 무엇인지 알려주는 것이므로, 해당 상황에 적합합니다.

    <br>

6. 도서 검색 사이트에서 도서 제목을 바탕으로 검색 기능을 구현하려고 합니다. 요청이 REST 원칙에 적합하도록 하려면 어떻게 해야 할까요?
    ```json
    요청
    GET /books
    [헤더 생략]

    { "query": { "title": "code" } }


    정상 응답
    HTTP/1.1 200 OK
    [헤더 생략]
    {
        "books": [
            { "isbn": "9780132350884", "title": "Clean Code", "author": "Robert C.Martin", "price": "$42.47" },
            { "isbn": "0735619670", "title": "Code Complete", "author": "Steve McConnell", "price": "$24.17" }
        ]
    }
    ```

    A.
    검색이므로 POST 요청을 사용해야 한다.


    **B.
    GET 요청에는 Query Parameter를 사용해야 한다.**


    C.
    엔드포인트는 ```/search``` 와 같이 명명해야 한다.

    해설  
    도서 제목을 바탕으로 검색하는 기능을 구현한다는 것은 GET 요청을 사용하여 데이터를 조회하는 것을 의미합니다. 그러나 GET 요청의 경우 body가 존재하지 않기 때문에 이를 Query Parameter를 이용하여 구현해야 합니다.

    <br>

7. 다음은 유저가 영화를 보기 위해 좌석을 예매하기 위한 요청과 응답입니다. 다음 빈칸에 들어갈 것으로 옳은 것을 고르시오.

    ```json
    요청
    __(ㄱ)__ ____(ㄴ)______ HTTP/1.1
    [헤더 생략]
    { "user": "kimcoding" }


    정상 응답
    HTTP/1.1 201 ___(ㄷ)____
    [헤더 생략]
    { 
        "message": "예약이 성공적으로 진행되었습니다",
        "seat" : "g10",
        "user" : "_____(ㄹ)_____"
    }


    오류 응답
    HTTP/1.1 ______(ㅁ)______
    [헤더 생략]
    { 
    "message": "예약에 실패했습니다",
    "seat" : "g10",
    "status": "다른 사용자에 의해 예약됨"
    }
    ```
    A.
    (ㄱ) GET - (ㄴ) /reserve - (ㄷ) created - (ㄹ) kimcoding - (ㅁ) 503 Service Unavailable


    **B.
    (ㄱ) POST - (ㄴ) /seats/g10 - (ㄷ) created - (ㄹ) kimcoding - (ㅁ) 409 Conflict**


    C.
    (ㄱ) POST - (ㄴ) /reservation - (ㄷ) OK - (ㄹ) kimcoding - (ㅁ) 409 Conflict


    D.
    (ㄱ) PUT - (ㄴ) /seats - (ㄷ) created - (ㄹ) kimcoding - (ㅁ) 503 Service Unavailable


    HTTP 409 Conflict 응답 상태 코드는 서버의 현재 상태와 요청이 충돌했음을 나타냅니다. 충돌은 PUT 요청에 대응하여 발생할 가능성이 가장 높습니다. 예를 들어 서버에 이미 있는 파일보다 오래된 파일을 업로드하면 버전 제어 충돌이 발생하여 409 응답받을 수 있습니다.


    <br>

8. 다음은 영화 예매를 위한 요청과 응답입니다. 응답이 REST 원칙에 맞게 수정한 것을 모두 고르시오.

    ```json
    요청
    POST /seats/g10 HTTP/1.1
    [헤더 생략]
    { "user": "kimcoding" }


    정상 응답
    HTTP/1.1 200 OK
    [헤더 생략]
    { "message": "예약이 성공적으로 진행되었습니다" }


    오류 응답
    HTTP/1.1 409 Conflict
    [헤더 생략]
    { 
    "message": "예약에 실패했습니다",
    "seat" : "g10",
    "status": "다른 사용자에 의해 예약됨"
    }

    ```


    **A. 정상적으로 생성된 리소스에 대한 정보가 응답에 담겨야 한다.**


    **B. 정상 응답 코드는 201 Created 여야 한다.**


    C. 오류 응답 코드는 503 Service Unavailable 여야 한다.


    D. 응답 메시지는 영문으로 쓰여져야 한다.


    예약을 진행한다는 것은 "POST 요청에 의해 새로운 예약 정보가 ***생성*** 되는 것"을 의미하므로, 정상 응답 코드는 ```201 Created```가 적합합니다.

    또한 MDN의 201 Created에 대한 내용에 따르면, 정상적으로 생성된 리소스에 대한 내용을 응답 메시지의 본문(body)에 포함할 것을 안내하고 있습니다. 이는 REST 원칙에도 부합하며, 어떤 리소스에 영향을 끼쳤는지를 보다 명시적으로 설명할 수 있게 됩니다.

    오류 응답이 있더라도, 서비스를 사용할 수 없는 것이 아니므로 ```503 Service Unavailable```은 부적절하며, 응답 메시지의 영문/한글 여부는 전혀 상관이 없습니다.

    <br>

9. 게시판에서 10번 게시물을 삭제하는 엔드포인트를 작성하려고 합니다. 가장 적절한 것을 고르시오.


    A.
    ```DELETE /delete```  
    ```body: { "id": "10" }```


    **B.
    ```DELETE /articles/10```**


    C.
    ```DELETE /articles  ```
    ```body: { "id": "10" }```


    B와 C 모두 동일한 리소스에 대한 요청이지만, C의 경우와 같이 본문(body)을 통해 전달하는 것보다는, 엔드포인트에 리소스를 명시하는 편이 낫습니다.

    DELETE에 본문(body)을 실을 수 없는 것은 아니나, HTTP 스펙에 근거하여, 많은 백엔드 구현에서 본문을 같이 전달할 경우 DELETE 요청 자체를 거절하는 경우를 종종 발견할 수 있습니다. 따라서, 애초에 엔드포인트에서 어떤 리소스를 삭제하는지 명시하는 편이 더 낫습니다.