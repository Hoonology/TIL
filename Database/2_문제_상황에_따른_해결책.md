# 문제 상황에 따른 해결책
# INDEX
- 낮은 검색 성능 - 인덱싱
    - 효율적인 검색을 위한 시도
    - 데이터 검색에 도움을 주기 위한 메타데이터
    - 데이터에 영향을 주지 않는 인덱스
---

<br>
<br>

# 낮은 검색 성능 - 인덱싱
> 낮은 검색 기능 문제를 해결하기 위한 방법 - **인덱싱**

<br>

## 효율적인 검색을 위한 시도
### 데이터베이스의 핵심적인 기능 
1. 데이터 저장
2. 요청이 왔을 때 저장되어 있는 데이터 중에서 찾아 제공
> 데이터를 찾기 위해 <u>데이터베이스 전체를 스캔하는 것을 방지</u>하기 위해 특정 <u>키 값을 확인하고 제공한다. - 인덱스를 이용</u>

<br>

## 데이터 검색에 도움을 주기 위한 **메타데이터**
데이터의 위치를 찾는데 도움을 주는 이정표 역할
> 기본 데이터에서 파생된 추가적인 구조

<br>

## 데이터에 영향을 주지 않는 인덱스
> 인덱스의 추가 삭제 허용 - 데이터베이스에 영향을 주진 않지만, 쿼리 성능에 영향을 준다.

<br>
<br>

# 많은 사용자 - 레플리카
> 많은 사용자가 발생함에 따른 문제를 해결하기 위한 방법 - 레플리카

 데이터베이스의 복사본을 저장하는 각각의 노드인 레플리카(replica : 복제서버)를 활용하여 문제를 해결  
 데이터의 중복성이 발생하는데, 이 중복성으로 인해서 얻을 수 있는 장점이 존재하며, 그에 따라 해결해야하는 문제점들 역시 존재한다.

## 장점
### 시스템 장애 발생시에도 동작할 수 있도록 가용성을 확보한다.  
 레플리카를 활용한 데이터베이스 구조를 구현할 경우 일부 노드가 사용불가능 상태라면 해당 데이터는 남은 다른 노드를 통해 여전히 제공할 수 있다는 장점이 있다.
 > 리더가 되는 데이터베이스와 동일한 데이터를 레플리카들이 가지고 있기 때문에, 리더 데이터베이스에 화재, 지진, 네트워크 오류 등의 장애 상황이 발생하더라도  
 레플리카 중 하나를 새로운 리더로 지정하고 사용자의 요청을 새로운 리더로 연결하여, 서비스가 중단되는 시간을 최소화 할 수 있다.

- 레플리카 데이터베이스는 원본 데이터베이스와 동일한 스키마를 사용하므로 응용 프로그램에서 변경할 필요가 없다.
- 레플리카 데이터베이스를 사용하면 읽기 작업을 분산시키고, 읽기 작업을 처리하는 데 필요한 시간을 줄일 수 있다.
- 레플리카 데이터베이스는 원본 데이터베이스와 동일한 스키마를 사용하므로 쓰기 작업은 원본 데이터베이스에서만 수행할 수 있다.

### 읽기 쿼리 제공 장비 수를 확장해 읽기 처리량을 늘림
> 웹 기반 애플리케이션 : 읽기 > 쓰기  

- 읽기 요청이 하나의 데이터베이스에 쏠리게 되면 발생하는 성능저하 문제 해결
    - 레플리카를 읽기전용 데이터베이스로 활용한다.
    - 레플리카는 최종적으로 리더와 같은 데이터를 가지고 있기 때문에 사용자들이 읽기 요청을 보낼 때 해당사항을 처리하고,  
    사용자 트래픽이 각 데이터베이스로 분산되기 때문에 성능향상에 도움이 된다.

### 지연시간 감소
> 데이터베이스가 데이터를 요청하는 곳과 지리적으로 멀게 되면 응답시간이 늦어진다.  

레플리카의 위치를 각 지역에 분산시켜 배치하면서 지연시간을 감소시킨다.

<br>
<br>

## 레플리카 활용 시 고려해야할 사항
모든 데이터베이스가 정확히 같은 데이터를 가지고 있게 한다.  
리더 데이터베이스에 저장 + 모든 레플리카에도 똑같이 저장  
- 동기식 복제
- 비동기식 복제


### 동기식 복제
동기식으로 복제가 진행되는 레플리카 구조에서는 리더의 데이터 처리와 별개로 레플리카에서의 데이터 처리까지 모두 완료되어야만 프로세스가 진행되고, 레플리카와 리더 데이터베이스가 일관성 있게 최신 데이터 복사본을 가지고 있는 것을 보장할 수 있다.  

![동기](./assets/%EB%8F%99%EA%B8%B0.png)  

동기식 복제의 경우 네트워크 문제나, 다른 이유로 레플리카가 정상적으로 데이터처리 작업을 완료할 수 없는 경우 응답을 받지 못한 리더 데이터베이스 역시 프로세스를 진행하지 못한다. 리더는 모든 쓰기를 차단하고 동기 레플리카가 회복되기를 기다리기 때문에 시스템 운영이 멈출수 있는 위험이 있다.

![동기문제](./assets/%EB%8F%99%EA%B8%B0%EB%AC%B8%EC%A0%9C.png)


### 비동기 복제
리더가 레플리카의 처리 응답을 기다리지 않는다. 리더는 레플리카에 데이터 처리를 요청한 후 자신의 작업을 완료하면 사용자의 요청에 바로 응답하고 쓰기 처리를 계속할 수 있다.  
리더 데이터베이스에 문제만 없다면 레플리카의 상태와 무관하게 사용자에게 서비스를 지속적으로 제공한다.

![비동기](./assets/%EB%B9%84%EB%8F%99%EA%B8%B0.png)  

하지만 레플리카가 **읽기 전용**으로 이용되고 있을 경우, 사용자에게 리더와 같은 응답을 주지 못하는 경우가 발생할 수 있다.  
데이터의 불일치가 발생하기 때문에 불일치 상태가 길어지는 경우 큰 문제가 될 수 있고,  
리더가 잘못되고 복구할 수 없는 상황이 발생 시, 팔로워에게 복제되지 못한 모든 처리가 유실될 수 있으며, 클라이언트에게는 정상 작동을 알린 이후임에도 불구하고 지속성을 보장하지 못하는 문제가 발생할 수 있다.  

![비동기문제](./assets/%EB%B9%84%EB%8F%99%EA%B8%B0%EB%AC%B8%EC%A0%9C.png)

### 반동기식 복제
두 복제 방식의 장단점 보완
- 래플리카 1 : 동기식 복제
- others : 비동기식 복제

![반동기](./assets/%EB%B0%98%EB%8F%99%EA%B8%B0.png)


## 대용량의 데이터 - 파티셔닝
### 대용량 데이터를 처리하기 위해 데이터셋을 자른다.
데이터셋이 큰 경우 + 쿼리 처리량이 매우 높은 경우 -> 단순 복제는 어렵다.  
> 파티션 = 작은 데이터베이스  

> 파티션으로 쪼갠다. ( 샤딩(Sharding) 한다. )  

### 파티셔닝의 목적
#### 확장성



---
<br>
<br>
<br>
<br>
<br>


# 퀴즈
다음 인덱싱에 대한 설명 중 틀린 것을 고르시오.

정답

A.
인덱스의 수정은 데이터베이스에 저장된 기본데이터(primary data)에 영향을 줍니다.


B.
인덱스는 원하는 데이터를 찾기 위한 이정표의 역할을 합니다.


C.
인덱스의 추가 삭제는 허용됩니다.

정답

D.
인덱스의 편집사항은 쿼리 성능에는 영향을 주지 않습니다.

해설
인덱스에 대한 수정은 기본데이터에는 영향을 주지 않고, 쿼리 성능에만 영향을 줍니다.

다음 중 인덱싱을 사용할 때 고려해야하는 사항으로 가장 적절한 것을 고르시오.


A.
핫스팟 방지를 위해 쏠림현상을 줄이기 위한 분산 설계가 필요합니다.

정답

B.
별도의 저장 공간을 확보하고 목적과 상황에 맞게 데이터에 연계된 메타데이터를 구성해야합니다.


C.
비동기적인 방식을 사용할 때, 데이터의 불일치 문제를 해결해야합니다.

해설
1번은 파티셔닝, 3번은 레플리카에 해당하는 설명입니다.  

당신은 시스템 모니터링을 통해 A사의 서비스가 쓰기 처리량보다 읽기 처리량이 훨씬 많다는 사실을 알아냈습니다. 당신은 잦은 조회가 발생하는 데이터에 대해서 캐싱을 통해 서비스 성능 향상을 제안하려고합니다. 가장 적합한 캐싱유형은 무엇인가요.


A.
Write-behind(back) Cache


B.
Read-through/Write-through Cache

정답

C.
Cache-aside

해설
읽기 처리량이 많은 경우에 Cache-aside 패턴이 활용됩니다.

파티셔닝을 사용할 때 분산을 통해 쏠림현상(skewed)를 방지해야하는 이유로 가장 적합한 것을 고르시오.

정답

A.
핫스팟 발생을 방지하고, 구성한 인프라의 성능을 제대로 발휘하기 위함입니다.


B.
데이터의 분산배치를 통해 고가용성을 확보하기 위함입니다.


C.
관리 리소스 줄이기 위해서 모든 데이터를 하나의 고성능 노드에서 처리할 수 있게 하기 위함입니다.


D.
자주 사용되는 데이터들을 별도의 저장소에 저장해서 애플리케이션 성능을 향상 시키기 위함입니다.

해설
레플리카의 목적에 해당하는 설명입니다.
파티셔닝 전략과 반대되는 설명입니다.
캐시의 목적에 해당하는 설명입니다.